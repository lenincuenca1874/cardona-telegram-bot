import os, io, json, logging, datetime as dt
import pandas as pd, yfinance as yf, mplfinance as mpf
from telegram import Bot

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ConfiguraciÃ³n bÃ¡sica â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
TOKEN = os.environ['TELEGRAM_TOKEN'].strip()
CHAT  = os.environ['TELEGRAM_CHAT_ID'].strip()
bot   = Bot(token=TOKEN)

TICKERS = [
    "SPY","QQQ","META","AAPL","AMZN","NFLX","MRNA","TSLA",
    "NVDA","TNA","GLD","SLV","USO","BAC","CVX","XOM"
]

LOGFILE = "signals_today.json"          # <â”€ registro diario

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Estrategias rÃ¡pidas â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def gap_bajista(df):
    prev, cur = df.iloc[-2], df.iloc[-1]
    return prev['Close'] > prev['Open'] and cur['Open'] < prev['Low']

def gap_alcista(df):
    prev, cur = df.iloc[-2], df.iloc[-1]
    return prev['Close'] < prev['Open'] and cur['Open'] > prev['High']

def ruptura_canal(df):
    sma = df['Close'].rolling(12).mean()
    return df['Close'].iloc[-2] < sma.iloc[-2] and df['Close'].iloc[-1] > sma.iloc[-1]

def piso_techo_fuerte(df):
    last4 = df.tail(4)
    return (last4['High'].idxmax() == last4.index[-1] and
            last4['Close'].iloc[-1] < last4['Open'].iloc[-1])

STRATEGIES = {
    "Gap Bajista": gap_bajista,
    "Gap Alcista": gap_alcista,
    "Ruptura Canal": ruptura_canal,
    "Piso-Techo Fuerte": piso_techo_fuerte
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Utilidades I/O â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def fetch(tkr, days=5):
    return yf.download(tkr, period=f"{days}d", interval="60m", progress=False)

def save_hit(rec):
    data = []
    if os.path.exists(LOGFILE):
        with open(LOGFILE,'r') as f:
            try:
                data = json.load(f)
            except json.JSONDecodeError:
                pass
    data.append(rec)
    with open(LOGFILE,'w') as f:
        json.dump(data, f, indent=2)

def ny_time():
    return dt.datetime.now(dt.timezone.utc).astimezone(
        dt.timezone(dt.timedelta(hours=-4)))   # horario verano NY

def send_chart(tkr, df, caption):
    buf = io.BytesIO()
    mpf.plot(df.tail(50), type='candle', style='yahoo',
             mav=(20,40), volume=True,
             savefig=dict(fname=buf, dpi=120))
    buf.seek(0)
    bot.send_photo(CHAT, buf, caption=caption[:1024])

def send_signal(tkr, strat, df):
    now = ny_time()
    ts  = now.strftime('%Y-%m-%d %H:%M')
    price = df['Close'].iloc[-1]

    # --------- registrar hit antes de enviar grÃ¡fico ---------
    save_hit({"tkr": tkr, "strat": strat, "time": ts})

    text  = (f"âš¡ï¸ *SeÃ±al {strat}*\n"
             f"*{tkr}* @ {price:,.2f}  ({ts} NY)\n"
             "_Premisa_: strike 1 sem fuera-del-dinero\n"
             "_AcciÃ³n_: TP parcial al duplicar\n")
    bot.send_message(CHAT, text, parse_mode='Markdown')
    send_chart(tkr, df, f"{tkr} â€“ {strat}")

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Escaneo principal â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def scan():
    hits = 0
    for tkr in TICKERS:
        try:
            df = fetch(tkr)
            if df.empty:
                continue
            for name, fn in STRATEGIES.items():
                if fn(df):
                    send_signal(tkr, name, df)
                    hits += 1
        except Exception as e:
            logging.error(f"{tkr} â€“ {e}")

    if not hits:
        bot.send_message(CHAT, "ðŸ” No hay seÃ±ales vÃ¡lidas en esta pasada.")

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Main loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if __name__ == "__main__":
    bot.send_message(CHAT, "â™»ï¸ CardonaBot realtime online (GitHub)")
    scan()
